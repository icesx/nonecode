微服务
=====
微服务是一种以业务功能为主的服务设计概念，每一个服务都具有自主运行的业务功能，对外开放不受语言限制的 API (最常用的是 HTTP)，应用程序则是由一个或多个微服务组成。

微服务的另一个对比是**[单体式应用程序](https://zh.wikipedia.org/wiki/單體式應用程式)**。单体式应用表示一个应用程序内包含了所有需要的业务功能，并且使用像[主从式架构](https://zh.wikipedia.org/wiki/主從式架構) (Client/Server) 或是[多层次架构](https://zh.wikipedia.org/w/index.php?title=多層次架構&action=edit&redlink=1) (N-tier) 实现，虽然它也是能以分布式应用程序来实现，但是在单体式应用内，每一个业务功能是不可分割的。若要对单体式应用进行扩展则必须将**整个**应用程序都放到新的运算资源（如：虚拟机） 内，但事实上应用程序中最吃资源、需要运算资源的仅有某个业务部分（例如跑分析报表或是数学算法分析），但因为单体式应用无法分割该部分，因此无形中会有大量的资源浪费的现象。

微服务运用了以业务功能的设计概念，应用程序在设计时就能先以业务功能或流程设计先行分割，将各个业务功能都独立实现成一个能自主运行的个体服务，然后再利用相同的协议将所有应用程序需要的服务都组合起来，形成一个应用程序。若需要针对特定业务功能进行扩展时，只要对该业务功能的服务进行扩展就好，不需要整个应用程序都扩展，同时，由于微服务是以业务功能导向的实现，因此不会受到应用程序的干扰，微服务的管理员可以视运算资源的需要来配置微服务到不同的运算资源内，或是布建新的运算资源并将它配置进去。

虽然使用一般的[服务器虚拟化](https://zh.wikipedia.org/w/index.php?title=伺服器虛擬化&action=edit&redlink=1)技术就能应用于微服务的管理，但容器技术 (Container Technology) 如 [Docker](https://zh.wikipedia.org/wiki/Docker) 会更加地适合发展微服务的运算资源管理技术。



### 数据库[[编辑](https://zh.wikipedia.org/w/index.php?title=微服務&action=edit&section=3)]

微服务理念中有数个数据库的规划方式。

- 每个服务都各有一个数据库，同属性的服务可共享同个数据库。
- 所有服务都共享同个数据库，但是不同表格，并且不会跨域访问。
- 每个服务都有自己的数据库，就算是同属性的服务也是，数据库并不会共享。

数据库并不会只存放该服务的数据，而是“**该服务所会用到的所有数据**”。更深层一点的举例：假设有个文章服务，而这个服务可能会需要判断用户的账号⋯⋯等。那么文章服务的数据库就可以放入用户的部分数据。此举是为了避免服务之间的相依性，避免文章服务调用用户服务。

#### 数据库的可弃性[[编辑](https://zh.wikipedia.org/w/index.php?title=微服務&action=edit&section=4)]

实践微服务有许多的做法，但其中一种做法是将数据库作为**短期**的存储空间而不是存储长期的数据。这意味着数据库可以在离线时被清空。因为它们可以在上线时从事件存储中心恢复，因此也能以存储器缓存（如：[Redis](https://zh.wikipedia.org/wiki/Redis)） 作为数据库服务器。但这种做法需要将每个请求当作事件来进行广播。如此一来就可以从事件存储中心重播所有的事件来找回所有的数据。

### 沟通与事件广播[[编辑](https://zh.wikipedia.org/w/index.php?title=微服務&action=edit&section=5)]

[![img](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/NSQ.png/306px-NSQ.png)](https://zh.wikipedia.org/wiki/File:NSQ.png)

NSQ 是一个消息队列系统、平台。在微服务中所扮演的角色是将消息、数据传递到其他服务。 此举是异步运行，所以不需要等到其他服务接收到消息就能够运行下一步。这种方式能够避免服务之间有所牵连、调用。

微服务中最重要的就是每个服务的独立与自主，因此服务与服务之间也**不应该**有所沟通。倘若真有沟通，也应采用异步沟通的方式来避免紧密的相依性问题。要达到此目的，则可用下列两种方式：

#### 事件存储中心（Event Store）[[编辑](https://zh.wikipedia.org/w/index.php?title=微服務&action=edit&section=6)]

这可以让你在服务集群中广播事件，并且在每个服务中监听这些事件并作处理，这令服务之间没有紧密的相依性，而这些发生的事件都会被保存在事件存储中心里。这意味着当微服务重新上线、部署时可以重播（Replay）所有的事件。这也造就了微服务的数据库随时都可以被删除、摧毁，且不需要从其他服务中获取数据。

#### 消息队列（Message Queue）[[编辑](https://zh.wikipedia.org/w/index.php?title=微服務&action=edit&section=7)]

这令你能够在服务集群中广播消息，并传递到每个服务中。具有这个功能的像是 NSQ 或是 [RabbitMQ](https://zh.wikipedia.org/wiki/RabbitMQ)。你能够在 A 服务上广播一个“创建新用户”的事件，这个事件可以顺便**带有**新用户的数据。而 B 服务可以**监听**这个事件并在接收到之后有所处理。这些过程都是异步处理的，这意味着 A 服务并不需要等到 B 服务处理完该事件后才能继续，而这也代表 A 服务无法获取 B 服务的处理结果。与事件存储中心近乎相似，但有所不同的是：消息队列并**不会**保存事件。一旦事件被消化（接收）后就会从队列中消失，这很适合用在像发送欢迎信件的时机。

